import React from 'react';
import { Link } from 'react-router-dom';

import InlineEdit from '../../shared/components/edit-inline/EditInline';
import SimpleForm from '../containers/simple-form/SimpleForm';
import ErrorLoading from '../components/error-loading/ErrorLoading';
import FrameworkVersions from '../containers/framework-versions/FrameworkVersions';
import VersionControls from '../containers/version-controls/VersionControls';

import { withSnackbar } from 'notistack';
import CompetencyService from '../services/competency/competency';
import ActiveRequestsService from '../services/active-requests/active-requests';

import 'react-responsive-modal/styles.css';
import { Modal } from 'react-responsive-modal';

class ManageData extends React.Component {
  activeRequests = new ActiveRequestsService();
  competencyService = new CompetencyService();
constructor(props) {
    super(props);
    this.state = {
      framework: '',
      frameworkName: '',
      frameworkData: [],
      frameworkVersion: '',
      frameworkVersionId: '',
      frameworkStatus: '',
      frameworkDef: [],
      competencyTypes: [],
      versions: [],
      loadingError: false,
      editable: false,
      allowedFrms:[],
      showModal: false,
      showAttributeModal: false,
      newDomains: '',
      newAttributes: '',
      parent:'',
      attributeType: ''
    };
    this.handleOpenModal = this.handleOpenModal.bind(this);
    this.handleCloseModal = this.handleCloseModal.bind(this);

    this.handleOpenAttributeModal = this.handleOpenAttributeModal.bind(this);
    this.handleCloseAttributeModal = this.handleCloseAttributeModal.bind(this);

    this.saveDomains = this.saveDomains.bind(this);
  }

  handleOpenModal() {
    this.setState({ showModal: true });
  }

  handleCloseModal() {
    this.setState({ showModal: false });
  }

  handleOpenAttributeModal(e){
    this.setState({showAttributeModal:true})
    this.setState({parent:e.target.dataset.competency})
    this.setState({attributeType:e.target.dataset.attributetype})
    e.preventDefault();
  }

  handleCloseAttributeModal(){
    this.setState({showAttributeModal:false})
  }


  static getDerivedStateFromProps(props, state) {
    const { framework } = props.match.params;
    if (framework !== state.framework) {
      return {
        framework,
        frameworkData: [],
        loadingError: false
      };
    }

    // No state update necessary
    return null;
  }

  async componentDidMount() {
    const { framework, domainId } = this.props.match.params;
    await this.loadData(framework);

    if (domainId) {
      setTimeout(() => {
        const ref = this.refs[domainId];
        if (ref) {
          ref.scrollIntoView();
        }
      }, 100);
    }

    // fetch(`https://dev-competency-mapper.pantheonsite.io/api/authorisation/cath?_format=json`,{
    //   method: 'GET',
    //   credentials: 'include'
    // })
    // .then(Response => Response.json())
    // .then(findResponse => 
    //   this.setState({allowedFrms: findResponse})
    // );
    
  }

  async componentDidUpdate(prevProps, prevState) {
    const { framework, frameworkData, loadingError } = this.state;
    if (framework !== prevState.framework) {
      if (frameworkData.length === 0 && !loadingError) {
        this.loadData(framework);
      }
    }
  }

  async loadData(framework) {
    try {
      this.activeRequests.startRequest();
      await this.fetchVersions(framework);
      await this.fetchFramework(framework);
    } catch (error) {
      this.setState({ loadingError: true });
    } finally {
      this.activeRequests.finishRequest();
    }
  }

  async fetchVersions(framework) {
    const allFrameworks = await this.competencyService.getAllVersionedFrameworks();
    const currentFramework = allFrameworks.filter(
      fw => fw.title.toLowerCase() === framework
    );
    if (currentFramework.length > 0) {
      this.setState({ versions: currentFramework[0].versions.reverse() });
      this.setState({frameworkDef: currentFramework[0].attribute_types})
    }
  }

  async fetchFramework(framework) {
    const { versions } = this.state;
    const liveVersion = versions.filter(version => version.status === 'live');
    const draftVersion = versions.filter(version => version.status === 'draft');
    let frameworkData = [];
    let editable = false;
    if (draftVersion.length) {
      frameworkData = await this.competencyService.getVersionedDraftFramework(
        framework
      );
      this.setState({ frameworkVersionId: draftVersion[0].id });
      editable = true;
    } else {
      if (liveVersion.length) {
        frameworkData = await this.competencyService.getVersionedFramework(
          framework,
          liveVersion[0].number
        );
      }
    }

    if (frameworkData.length) {
      const competencyTypes = frameworkData[0].domains.map(domain => ({
        description: domain.title,
        uuid: domain.uuid
      }));
      this.setState({
        frameworkName: frameworkData[0].title,
        frameworkData,
        frameworkVersion: frameworkData[0].version,
        frameworkStatus: frameworkData[0].status,
        competencyTypes,
        editable
      });
    }
  }

  createCompetency = async (description, domainUuid, mapping) => {
    const { framework, frameworkData, versions } = this.state;
    const draftVersion = versions.filter(version => version.number === 'draft');
    try {
      this.activeRequests.startRequest();
      const domainId = frameworkData[0].domains.find(
        domain => domain.uuid === domainUuid
      ).nid;
      const draftId = draftVersion[0].id;
      const draftUuid = draftVersion[0].uuid;
      await this.competencyService.createCompetency({
        description,
        domainId,
        domainUuid,
        mapping,
        draftId,
        draftUuid
      });
      await this.fetchFramework(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
  };

  async editCompetency(cid, title) {
    const { framework } = this.state;
    try {
      this.activeRequests.startRequest();
      await this.competencyService.patchCompetency(cid, 'title', title);
      await this.fetchFramework(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
  }

  async editCompetencyPosition(cid, position) {
    const { framework } = this.state;
    try {
      this.activeRequests.startRequest();
      await this.competencyService.patchCompetencyPosition(
        cid,
        'field_number',
        position
      );
      await this.fetchFramework(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
  }

  async editAttribute(aid, title) {
    const { framework } = this.state;
    try {
      this.activeRequests.startRequest();
      await this.competencyService.patchCompetency(aid, 'title', title);
      await this.fetchFramework(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
  }

  async toggleArchive(nid, isArchived) {
    const { framework } = this.state;
    try {
      this.activeRequests.startRequest();
      await this.competencyService.toggleArchivingVersionedNode(framework, nid);
      await this.fetchFramework(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
  }

  releaseNewVersion = async (version, notes) => {
    const { framework } = this.state;
    try {
      this.activeRequests.startRequest();
      await this.competencyService.publishFramework(framework, version, notes);
      this.loadData(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
  };

  updateNotes = async notes => {
    const { framework, frameworkVersionId } = this.state;
    try {
      this.activeRequests.startRequest();
      await this.competencyService.updateReleaseNotes(
        notes,
        frameworkVersionId
      );
      this.loadData(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
  };

  createDraft = async () => {
    const { framework } = this.state;
    try {
      this.activeRequests.startRequest();
      await this.competencyService.createDraftFramework(framework);
      this.loadData(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
  };

  getCompetencyList() {
    const { frameworkData, editable } = this.state;
    return frameworkData[0].domains.map(domain => (
      <React.Fragment key={domain.nid}>
        <tr
          className="domain-row"
          ref={domain.nid}
        >
          <td>
           <div className="column medium-9"> <h4>{domain.title} </h4></div>  
           <div className="column medium-3"> <a href="#" className="addButton" onClick={this.handleOpenModal}>
              {/*<i className="icon icon-common icon-plus-square"></i>*/} Add competencies</a>
            </div>
          </td>
          {editable && <td className="small-1">Position</td>}
          {/* editable && <td className="small-1">Archive</td>*/}
          <td>Attributes</td>
          {editable && <td className="small-1">Settings</td>}
        </tr>
        {this.getCompetencyRows(domain.competencies)}
      </React.Fragment>
    ));
  }

  getCompetencyRows(competencies) {
    const { framework, editable } = this.state;
    return competencies.map(competency => {
      if (editable) {
        return (
          <React.Fragment>
          <tr key={competency.id}>
            <td className={competency.archived === '1' ? 'strikeout' : ''}>
              <h5>
                <InlineEdit
                  text={competency.title}
                  change={newValue =>
                    this.editCompetency(competency.id, newValue)
                  }
                  editable={competency.archived === '1' ? false : true}
                />
              </h5>
            </td>
            <td>
              <InlineEdit
                text={competency.position}
                change={newValue =>
                  this.editCompetencyPosition(competency.id, newValue)
                }
                editable={competency.archived === '1' ? false : true}
              />
            </td>

            {/*<td>
              <button
                className="cursor"
                onClick={this.toggleArchive.bind(
                  this,
                  competency.id,
                  competency.archived
                )}
              >
                {competency.archived === '1' ? (
                  <span className="fas fa-toggle-on">
                    <span>Archived</span>
                  </span>
                ) : (
                  <span className="fas fa-toggle-off" />
                )}
              </button>
            </td>*/}
            <td>
              <Link
                to={`/framework/${framework}/manage/competencies/${
                  competency.id
                }/manage-attributes`}
              >
                <i className="fas fa-sitemap" />
              </Link>
            </td>

            <td>
              <Link
                to={`/framework/${framework}/competency/${
                  competency.id
                }/settings`}
              >
                <i className="fas fa-cog" />
              </Link>
            </td>
          </tr>
          <tr>
            <td>
             <ul className="attribute_section"> {this.getAttributeRows(competency.id, competency.attributes)}</ul>
            </td>
          </tr>
          </React.Fragment>
        );
      }

      if (competency.archived === '1') {
        return null;
      }

      return (
        <tr key={competency.id}>
          <td>
            <InlineEdit
              text={competency.title}
              change={newValue => this.editCompetency(competency.id, newValue)}
              editable={editable}
            />
          </td>
          <td>
            <Link
              to={`/framework/${framework}/manage/competencies/${
                competency.id
              }/manage-attributes`}
            >
              <i className="fas fa-sitemap" />
            </Link>
          </td>
        </tr>
      );
    });
  }

  getAttributeRows(cid, attributes){
    return this.state.frameworkDef.map(def => 
      <li className="attribute_type">{def.title} 
        <a className="addButton" style={{float:'right'}} data-competency={cid} data-attributetype={def.id} title="Add attributes" href="#" onClick={e => this.handleOpenAttributeModal(e)}>
          {/*<i className="icon icon-common icon-plus-square" data-competency={cid} data-attributetype={def.id}></i>*/} Add {def.title}
        </a>
        <p></p>
        <ul>
          {attributes.map(attr => {
            if(attr.type == def.title)
            return <li className={attr.archived === '1' ? 'strikeout row-item' : 'row-item'}>
                    <InlineEdit style={{display:'inline'}}
                      text={attr.title}
                      change={newValue =>
                        this.editAttribute(attr.id, newValue)
                      }
                      editable={attr.archived === '1' ? false : true}
                    /> 
                    <span className="edit-indicator">
                      {/*<a href="#" onClick={this.toggleArchive.bind(this, attr.id, attr.archived)}>
                        <i key="dummy" className="fas fa-toggle-off" aria-label="archive"/>
                      </a>*/}

                      <button
                      className="cursor"
                      onClick={this.toggleArchive.bind(
                        this,
                        attr.id,
                        attr.archived
                      )}
                    >
                      {attr.archived === '1' ? (
                        <span className="fas fa-toggle-on">
                          <span>Archived</span>
                        </span>
                      ) : (
                        <span className="fas fa-toggle-off icon-left-spacer"> <span> Archive</span></span>
                      )}
                    </button>

                    </span>
                    <p></p>
                  </li>

          })}
        </ul>
      </li>
    )
  }



  setDomains(e){
    this.setState({newDomains:e.target.value})
  }


  saveDomains = async (e) => {
    const { framework, frameworkData, newDomains } = this.state;

    let parentID = frameworkData[0].nid;
    let versionID = frameworkData[0].version_id;
    let newData = newDomains;
    let type = "domain";
    let addtional = "";

    try {
      this.activeRequests.startRequest();
      await this.competencyService.createBulkData(parentID, versionID, newData, type, addtional);
      this.loadData(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
    e.persist();
    this.handleCloseModal();
    this.props.enqueueSnackbar('Domains created', {
        variant: 'success'
      });
  };


  setAttributes(e){
    this.setState({newAttributes:e.target.value})
  }

  saveAttributes = async (e) => {
    const { framework, frameworkData, newAttributes, attributeType, parent } = this.state;
    let parentID = parent;
    let versionID = frameworkData[0].version_id;
    let newData = newAttributes;
    let type = 'attribute';
    let addtional = attributeType;

    try {
      this.activeRequests.startRequest();
      await this.competencyService.createBulkData(parentID, versionID, newData, type, addtional);
      await this.loadData(framework);
    } catch (e) {
      this.props.enqueueSnackbar('Unable to perform the request', {
        variant: 'error'
      });
    } finally {
      this.activeRequests.finishRequest();
    }
    e.persist();
    this.handleCloseAttributeModal();
    this.props.enqueueSnackbar('Attributes created', {
        variant: 'success'
      });
  };

  render() {
    // if(this.state.allowedFrms.length > 0){
    //   if(this.state.allowedFrms.indexOf(this.state.framework) == -1){        
    //     return(<h4 className="callout warning"> <i class="icon icon-common icon-exclamation-triangle"></i> You are not authorised to manage this framework </h4> );
    //   }
    // }
    

    const {
      framework,
      frameworkName,
      frameworkData,
      frameworkVersion,
      frameworkStatus,
      competencyTypes,
      versions,
      loadingError,
      editable
    } = this.state;



    if (loadingError) {
      return <ErrorLoading />;
    }

    if (frameworkData.length === 0) {
      return null;
    }

    return (
      <div className="row">
        <h2>Manage framework data</h2>
        <h4>{frameworkName}</h4>

        

        <p>
          <span className="tag">{frameworkVersion}</span>
          <span className="tag secondary-background">
            {frameworkStatus === '' ? 'draft' : frameworkStatus}
          </span>
        </p>

        <div className="row">
          
          <div className="column medium-9">
             <VersionControls
              editable={editable}
              createDraft={this.createDraft}
              versions={versions}
              release={this.releaseNewVersion}
              updateNotes={this.updateNotes}
            />
          </div>

          <div className="column medium-3">
            <button className="button secondary float-right" onClick={this.handleOpenModal}> Add domains <i className="icon icon-common icon-plus-square"></i></button>
          </div>

        </div>
         

          

        {editable && (
          <SimpleForm
            title="Create new competency"
            placeholder="Competency description"
            options={competencyTypes}
            onCreate={this.createCompetency}
            showMappingField={true}
          />
        )}

        <table>
          <tbody>{this.getCompetencyList()}</tbody>
        </table>

        <FrameworkVersions framework={framework} versions={versions} />

        <div style={{ overflow: 'scroll' }}>

          <Modal id="attribute_modal" open={this.state.showAttributeModal} onClose={this.handleCloseAttributeModal} center
            classNames={{
              overlay: 'customOverlay',
              modal: 'customModal',
            }}
          >
            <h2>Add attributes</h2>
            <p>
              {this.state.parent}
            </p>
            <p>
              {this.state.frameworkVersionId}
            </p>
            <p>
              {this.state.attributeType}
            </p>

            <form>  
              <textarea id="attribute_txt_area" rows="5" onChange={e => this.setAttributes(e)} required></textarea>
              <button className="button" onClick={e => this.saveAttributes(e)}>Save</button>
            </form>

          </Modal>


          <Modal open={this.state.showModal} onClose={this.handleCloseModal} center
            classNames={{
              overlay: 'customOverlay',
              modal: 'customModal',
            }}
          >
            <h2>Add domain(s) </h2>
            <h3>Please enter one domain per line</h3>
            {this.state.parent}
            <form>  
              <textarea id="domain_txt_area" rows="5" onChange={e => this.setDomains(e)} required></textarea>
              <button className="button" onClick={e => this.saveDomains(e)}>Save</button>
            </form>

            <form>
            <div className="callout">
              <label>Domain title</label>  
              <input type="text" />
              <label>Description</label>  
              <textarea></textarea>
            </div>

            <div className="callout">
              <label>Domain title</label>  
              <input type="text" />
              <label>Description</label>  
              <textarea></textarea>
            </div>

            <div>  <button className="button small secondary" onClick={e => this.saveDomains(e)}>Add more</button></div>
            <div>  <button className="button" onClick={e => this.saveDomains(e)}>Save</button></div>
            </form>
            
          </Modal>


        </div>



      </div>


      
    );
  }
}

export default withSnackbar(ManageData);
